; OLD FORMAT
;
; LDY 5               ; Loads the Y register with value 14
; LDA 0               ; Loads the A register with value 0
; LDX 1               ; Loads the X register with value 1
; WMA 0 100           ; Write value of register A to memory location 100
; AAX                 ; Adds A and X registers and stores in A register
; JMO 0 24            ; If A register overflowed, jump to memory location 24
; RMX 0 100           ; Load register X with value at memory location 100
; DEY                 ; Decrement register Y by 1
; JNZ 0 6             ; If Y is NOT zero (i.e. we're not finished), loop back to the start
; RMY 0 200           ; Load register Y with value at memory location 200
; HLT                 ; Halts the CPU
; RMX 0 200           ; Load register X with value at memory location 200
; INX                 ; Increment register X by 1
; WMX 0 200           ; Write value of register X to memory location 200
; JMP 0 13            ; Jump to memory location 13

; NEW FORMAT
;
:_START             ; Entry point
    LDY 5           ; Load 5 so we calculate the 6th fibonacci number (0-5)
    LDA 0           ; Load A with 0 (first fibonacci number)   
    LDX 1           ; Load X with 1 (second fibonacci number)
:LOOP               ; Main loop
    WMA $100        ; Write A to memory location $100
    AAX             ; Add A and X, store result in A
    JMO OVERFLOW    ; If A overflowed, jump to overflow handler
:NO_OVERFLOW        ; Continue if no overflow
    RMX $100        ; Load X with value at memory location $100
    DEY             ; Decrement Y
    JNZ LOOP        ; If Y is not zero, loop back to start
:EXIT               ; Exit point
    RMY $200        ; Load Y with value at memory location $200
    HLT             ; Halt the CPU   
:OVERFLOW           ; Overflow handler
    RMX $200        ; Load X with value at memory location $200
    INX             ; Increment X
    WMX $200        ; Write X to memory location $200
    JMP LOOP        ; Jump back to main loop